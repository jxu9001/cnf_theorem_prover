# Jerry Xu
# CS 4365 Spring 2021 Homework 3 Part 1
# I used the following command to run the theorem prover:
# python3 <filename> <path_to_kb_file>

import itertools
import sys


def main():
    # dictionary where k = clause and v = (parent_clause_1, parent_clause_2)
    global parents
    parents = {}

    # initialize needed data structures
    kb = []

    # command line args
    kb_file_name = sys.argv[1]

    # read the clauses in the kb file into the knowledge base
    with open(kb_file_name) as kb_file:
        for line in kb_file:
            kb.append(line.split())

    # as the last line in the .kb file is the clause to test, add the negation of its literals to the knowledge base
    clause_to_test = kb.pop(-1)
    for literal in clause_to_test:
        kb.append([negate(literal)])

    original_kb_len = len(kb)
    res = resolution(kb)

    # print results to screen
    print_clauses(kb, original_kb_len)

    if res:
        print("Valid")
    else:
        print("Invalid")


def resolution(kb):
    """
    implementation of the algorithm on page 255 of the textbook, 3rd edition
    """
    # new clauses generated through resolution
    new = []
    # using a set prevents the addition of logically equivalent clauses
    sorted_kb = set()

    # indexes of previously resolved clauses
    prev_resolved = set()

    for clause in kb:
        sorted_kb.add(tuple(sorted(clause)))

    while True:
        # get the length of the kb and pairs of clauses to resolve
        n = len(kb)

        for i in range(1, n):
            for j in range(i):
                if (i, j) not in prev_resolved:
                    res = resolve(kb[i], kb[j])

                    # [[]] indicates a contradiction
                    if res == [[]]:
                        for new_clause in new:
                            if tuple(sorted(new_clause)) not in sorted_kb:
                                sorted_kb.add(tuple(sorted(new_clause)))
                                kb.append(new_clause)
                        kb.append("Contradiction")
                        return True

                    # add resolvents to the list of newly generated clauses
                    for clause in res:
                        new.append(clause)

                prev_resolved.add((i, j))

        if is_sublist_of(new, kb):
            kb.append("Failure")
            return False

        # check if a newly generated clause is present in the kb before appending it
        for new_clause in new:
            if tuple(sorted(new_clause)) not in sorted_kb:
                sorted_kb.add(tuple(sorted(new_clause)))
                kb.append(new_clause)
        new = []


# HELPER FUNCTIONS #
def resolve(clause_1, clause_2):
    """
    returns a list of all possible resolutions of two clauses with tautologies and redundant literals removed
    """
    global parents
    resolvents = []
    for lit_1 in clause_1:
        for lit_2 in clause_2:
            if lit_1 == negate(lit_2) or lit_2 == negate(lit_1):
                # removing items from a python list while iterating over it causes some issues
                # so here is a workaround
                c1, c2 = clause_1 + [], clause_2 + []
                # remove the opposing literals
                c1.remove(lit_1)
                c2.remove(lit_2)
                resolvent = c1 + c2
                # get rid of tautologies and redundant literals
                if resolvent is not None:
                    resolvent = list(dict.fromkeys(resolvent))
                    if not tautology(resolvent):
                        resolvents.append(resolvent)

    # populate the parents{} dictionary
    flattened_resolvents = tuple(itertools.chain(*resolvents))
    if flattened_resolvents == () or flattened_resolvents not in parents:
        parents[flattened_resolvents] = [clause_1, clause_2]

    return resolvents


def negate(literal):
    """
    returns the negation of a literal
    e.g. "x" -> "~x" and "~y" -> "y"
    """
    if literal[0] == "~":
        return literal[1:]
    else:
        return "~" + literal


def tautology(clause):
    """
    returns true if a clause is a tautology, false otherwise
    """
    for literal in clause:
        if negate(literal) in clause:
            return True
    return False


def is_sublist_of(l1, l2):
    """
    returns true if l1 is a sublist of l2
    """
    for element in l1:
        if element not in l2:
            return False
    return True


def print_clauses(kb, original_kb_len):
    """
    prints the clauses generated by the theorem prover
    """
    for i, v in enumerate(kb):
        # original clauses in the kb don't have parent clauses
        if i < original_kb_len:
            line = str(i + 1) + ". " + ' '.join(v) + ' {}'
        else:
            # for all generated clauses in the kb besides the final one
            if i < len(kb) - 1:
                parent1 = str(get_parent_clauses(v, kb)[0])
                parent2 = str(get_parent_clauses(v, kb)[1])
                line = str(i + 1) + ". " + ' '.join(v) + ' {' + parent1 + ', ' + parent2 + '}'
            # for the final generated clause in the kb
            else:
                if v == "Failure":
                    line = str(i + 1) + ". " + v
                else:
                    parent1 = str(get_parent_clauses((), kb)[0])
                    parent2 = str(get_parent_clauses((), kb)[1])
                    line = str(i + 1) + ". " + v + ' {' + parent1 + ', ' + parent2 + '}'
        print(line)


def get_parent_clauses(clause, kb):
    """
    gets the line numbers of the parent clauses

    given a clause, look up its parents using the parents{} dictionary
    and then use the kb to find and return the line numbers of both parents
    """
    global parents
    return kb.index(parents[tuple(clause)][0]) + 1, kb.index(parents[tuple(clause)][1]) + 1


if __name__ == "__main__":
    main()
